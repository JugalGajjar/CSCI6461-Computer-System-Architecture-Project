LOC 6 		;STORES CURRENT TEXT CHARACTER LOCATION
Data 31
LOC 7		;STORES CURRENT SEARCH CHARACTER LOCATION
Data 2000
LOC 8		;CHECK EQUAL -> IF 0 THEN EQUAL, ELSE NOT EQUAL
Data 0
LOC 9		;PROGRAM START LOCATION
Data 100
LOC 10		;CHARACTER MATCH JUMP ADDRESS
Data 200
LOC 11		;WHITESPACE JUMP ADDRESS
Data 300
LOC 12		;MATCH FOUND
Data 400
LOC 13		;FLUSH VALUE
Data 0
LOC 14		;SENTENCE NUMBER
Data 1
LOC 15		;WORD NUMBER
Data 1
LOC 16		;SENTENCE JUMP ADDRESS
Data 500
LOC 17		;WORD NOT FOUND
Data 600
LOC 18		;SEARCH WORD START
Data 2000
LOC 31		;LOCATION FROM WHERE THE TEXT WILL BE STORED
<TEXT>
LOC 2000	;LOCATION FROM WHICH THE SEARCH WORD WILL BE STORED
<SEARCH>
LOC 100
LDX 1,6		;LOAD CURRENT TEXT CHARACTER ADDRESS
LDX 2,7		;LOAD CURRENT SEARCH CHARACTER ADDRESS
LDR 0,1,0	;LOAD CURRENT TEXT CHARACTER VALUE
LDR 1,2,0	;LOAD CURRENT SEARCH CHARACTER VALUE
LDR 2,1,0	;LOAD CURRENT TEXT CHARACTER VALUE FOR WHITESPACE CHECK
SIR 2,65	;CHECK FOR WHITESPACE
LDX 3,11	;LOAD WHITESPACE JUMP ADDRESS (LOC 300)
JZ 2,3,0	;JUMP IF WHITESPACE FOUND
LDR 2,1,0	;LOAD CURRENT TEXT CHARACTER VALUE FOR SENTENCE END (.) CHECK
SIR 2,100	;CHECK FOR FULL STOP
LDX 3,11	;LOAD SENTENCE JUMP ADDRESS (LOC 500)
JZ 2,3,0	;JUMP IF SENTENCE END FOUND
SMR 0,2,0	;SUBTRACT R0 WITH CURRENT SEARCH CHARACTER (RESULTS 0 IF EQUAL)
LDX 3,13	;FLUSH IX3
STR 0,3,8	;STORE THE CHARACTER EQUAL VALUE AT MEMORY[8]
LDX 3,10	;LOAD IX3 WITH CHARACTER MATCH JUMP LOCATION
JZ 0,3,0	;JUMP IF CHARACTER MATCH
LDX 3,13	;IF NOT JUMP, FLUSH IX3
LDR 2,3,6	;LOAD CURRENT TEXT CHARACTER LOCATION IN R2
AIR 2,1		;INCREMENT THE CURRENT TEXT LOCATION
STR 2,3,6	;STORE THE UPDATED VALUE
LDR 3,3,13	;FLUSH R3
JZ 3,3,9	;JUMP BACK TO PROGRAM START
LOC 200
LDX 3,13	;FLUSH IX3
LDR 2,3,6	;LOAD R2 WITH CURRENT TEXT CHARACTER LOCATION STORED AT MEMORY[6]
AIR 2,1		;INCREMENT CURRENT TEXT CHARACTER LOCATION
STR 2,3,6	;STORE THE UPDATED VALUE
LDR 2,3,7	;LOAD R2 WITH CURRENT SEARCH CHARACTER LOCATION STORED AT MEMORY[7]
AIR 2,1		;INCREMENT CURRENT SEARCH CHARACTER LOCATION
STR 2,3,7	;STORE THE UPDATED VALUE
LDR 3,3,13	;FLUSH R3
JZ 3,3,9	;JUMP BACK TO PROGRAM START
LOC 300
LDX 3,13	;FLUSH IX3
LDR 3,3,8	;PUT CHECK EQUAL VALUE IN R3 (IT SHOULD BE 0 IF CHARACTERS MATHCHED BEFORE ENDING CURRENT WORD)
JZ 3,3,12	;JUMP TO MEMORY[12]=LOC 400, IF WORD MATCH FOUND
LDR 3,3,15	;ELSE, LOAD WORD NUMBER IN R3
AIR 3,1		;INCREMENT WORD NUMBER BY 1
STR 3,3,15	;STORE UPDATED WORD NUMBER IN MEMORY[15]
LDR 3,3,18	;LOAD THE SEARCH WORD START LOCATION IN R3
STR 3,3,7	;RESET THE CURRENT SEARCH CHARACTER TO FIRST CHARACTER OF SEARCH WORD
LDR 3,3,13	;FLUSH R3
JZ 3,3,9	;JUMP BACK TO PROGRAM START
LOC 400
End: HLT 	;STOP WORD FOUND
LOC 500
LDX 3,13	;FLUSH IX3
LDR 3,3,8	;PUT CHECK EQUAL VALUE IN R3 (IT SHOULD BE 0 IF CHARACTERS MATHCHED BEFORE ENDING CURRENT SENTENCE)
JZ 3,3,12	;JUMP TO MEMORY[12]=LOC 400, IF WORD MATCH FOUND
LDR 3,3,16	;LOAD CURRENT SENTENCE NUMBER IN R3
SIR 3,6		;SUBTRACT 6 TO CHECK WHETHER WE ARE ON FINAL SENTENCE OR NOT (0 -> FINAL SENTENCE)
JZ 3,3,17	;JUMP TO WORD NOT FOUND ADDRESS IF LAST SENTENCE HAS ENDED
LDR 3,3,16	;LOAD CURRENT SENTENCE NUMBER IN R3
AIR 3,1		;INCREMENT SENTENCE NUMBER
STR 3,3,16	;STORE INCREMENTED VALUE
LDR 3,3,13	;FLUSH R3
AIR 3,1		;MAKE R3 = 1
STR 3,3,15	;RESET WORD NUMBER TO 1 FOR NEW SENTENCE
LDR 3,3,13	;FLUSH R3
JZ 3,3,9	;JUMP BACK TO PROGRAM START
LOC 600
End: HLT 	;STOP WORD NOT FOUND